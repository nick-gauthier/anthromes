---
title: "Reprojection"
author: "Nick Gauthier"
date: "7/23/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dggridR)
library(raster)
library(sf)
sf_use_s2(TRUE) # for s2 spherical geometry
library(exactextractr)
library(tidyverse)
devtools::load_all()
```

# Discrete Global Grid System

Generate an Icosahedral Snyder Equal Area Aperture 3 hexagonal grid. Use the Level 12 resolution for ~100km grid cells.
```{r}
# construct the DGG
dggs <- dgconstruct(res = 12)
```

Load a a set of DGG IDs we can use as a land mask. These are based on the intersection of the HYDE 3.2 land mask and previously generated Level 12 DGG grids from GLOBE. We use these precomputed IDs as a land mask for simplicity.
```{r}
dgg_ids <- read_csv('data/raw_data/dgg_ids.csv', col_types = 'ii') # read ids as integers
```

Create polygons from the DGG system and cell numbers from the HYDE land mask.
```{r}
dgg_land <- dgcellstogrid(dggs, dgg_ids$ANL12_ID, frame = FALSE, wrapcells = FALSE) %>%
  st_as_sf(crs = 4326) %>%
  bind_cols(dgg_ids) %>%
  st_wrap_dateline(options = c("WRAPDATELINE=YES", "DATELINEOFFSET=30"))
```

## Process HYDE fixed inputs, regions, and NMH layers

Load the necessary input rasters.
```{r}
land_area_rast <- raster('data/raw_data/supporting_5m_grids/maxln_cr.tif')
pot_veg_rast <- raster('data/raw_data/supporting_5m_grids/potveg15.tif')
pot_vill_rast <- raster('data/raw_data/supporting_5m_grids/potvill20.tif')
regions_rast <- raster('data/raw_data/simple_regions.tif')
nmh <- raster('../WCMC_natural_modified_habitat_screening_layer/natural_modified_habitat_screening_layer.tif')
```

```{r}
nmh_tibble <- exact_extract(nmh, dgg_land, function(value, frac) tapply(frac, value, sum) / sum(frac)) %>% 
  map(~{if(length(.) > 0})
  map(~{if(length(.) == 0) c(`1` = NA, `2` = NA, `3` = NA, `4` = NA) else .}) %>% 
  map_dfr(as.list) %>%
  replace_na(list(`1` = 0, `2` = 0, `3` = 0, `4` = 0)) %>% # turn na's into zeros
  transmute(nmh_4 = `4`, nmh_34 = `3` + `4`)
    
fixed_inputs <- dgg_ids %>%
  bind_cols(nmh_tibble) %>%
  mutate(area = exact_extract(land_area_rast, dgg_land, 'sum'), 
         pot_veg = exact_extract(pot_veg_rast, dgg_land, 'mode'),
         pot_vill = exact_extract(pot_vill_rast, dgg_land, 'mode'),
         region = exact_extract(regions_rast, dgg_land, 'mode'))
```



## Three Global Conditions Data
```{r}
tgc <- read_csv('data/raw_data/three_conditions_v4_rep_data.csv') %>% 
  dplyr::select(l1_id, biome, `@3_cond_v4`, hfp_max, pa_km2, kba_km2, ind_cnt, v_rich, v_thr) %>%
  rename(olson_biome = biome) %>% 
  left_join(dgg_land, by = c('l1_id' = 'L1_ID')) 
```

```{r}
bind_cols(tgc, nmh_tibble)
```


# HYDE to DGG
```{r}
dgg_land <- read_sf('l12_ISEA3H_dgg_land.shp')
```

Loop through each variable name, import HYDE rasters from each year, brick, and extract by DGG polygon.
```{r}
hyde2dgg <- function(hyde_varname, hyde_path){
  suppressWarnings(
    list.files(hyde_path, recursive = TRUE, full.names = TRUE) %>%
      str_subset(., hyde_varname) %>% 
      map(raster) %>%
      brick %>%
      `crs<-`(value = '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0') %>%
  exact_extract(dgg_land, 'sum')
  )
}
```

```{r}
hyde_names <- c('cropland', 'grazing', 'ir_rice', 'popc', 'tot_irri', 'uopp')

hyde_dgg <- hyde_names %>%
  map(hyde2dgg, '~/Downloads/baseline/zip') %>%
  bind_cols()

hyde_dgg_upper <- hyde_names %>%
  map(hyde2dgg, '~/Downloads/upper/zip') %>%
  bind_cols()

hyde_dgg_lower <- hyde_names %>%
  map(hyde2dgg, '~/Downloads/lower/zip') %>%
  bind_cols()
# check that ncol(hyde) == length(hyde_names) * length(time_steps)
```

```{r}
saveRDS(hyde_dgg, 'hyde_dgg')
saveRDS(hyde_dgg_upper, 'hyde_dgg_upper')
saveRDS(hyde_dgg_lower, 'hyde_dgg_lower')
```


# Anthromes classification

```{r}
dgg_ids <- readRDS('dgg_ids')
fixed_inputs <- read_csv('fixed_inputs.csv') %>%
  mutate(id = dgg_ids)
```

```{r}
hyde_dgg <- readRDS('hyde_dgg')

hyde_names_grepl <- str_c('cropland', 'grazing', 'ir_rice', 'popc', 'tot_irri', 'uopp', sep = '|')

var_names <- names(hyde_dgg) %>%
  str_extract(hyde_names_grepl)

time_steps <- names(hyde_dgg) %>%
  str_sub(start = str_length(var_names) + 5) %>%
  str_remove('_')

new_names <- paste(var_names, time_steps, sep = '.')

anthromes_dgg <- hyde_dgg %>%
    setNames(new_names) %>%
  mutate(id = dgg_ids) %>%
  split(1:200) %>%
  map_dfr(~gather(., key = 'name', value = 'value', -id) %>%
  separate(name, into = c('var', 'time_step'), sep = '[.]') %>%
  spread(var, value) %>%
  left_join(fixed_inputs, by = 'id') %>%
  mutate(crops = cropland / area,
            grazing = grazing / area,
            rice = ir_rice / area,
            pop = popc / area,
            irrigation = tot_irri / area,
            urban = uopp / area,
            used = urban + crops + grazing,
            .keep = 'unused') %>%
  anthromes_classify()) #%>%
## necessary to save ram, but not if run on cluster
write_csv(anthromes_dgg, 'anthromes_dgg2.csv')
gc()
read_csv('anthromes_dgg2.csv') %>%
  mutate(time_step = factor(time_step, levels = time_key$time_step)) %>%
  arrange(id, time_step) %>%
  spread(time_step, anthrome) %>%
  write_csv('anthromes_dgg.csv')
```

## classify uncertainties
```{r}
hyde_dgg_upper <- readRDS('hyde_dgg_upper')

hyde_names_grepl <- str_c('cropland', 'grazing', 'ir_rice', 'popc', 'tot_irri', 'uopp', sep = '|')

var_names <- names(hyde_dgg_upper) %>%
  str_extract(hyde_names_grepl)

time_steps <- names(hyde_dgg_upper) %>%
  str_sub(start = str_length(var_names) + 5) %>%
  str_remove('_')

new_names <- paste(var_names, time_steps, sep = '.')

anthromes_dgg_upper <- hyde_dgg_upper %>%
  setNames(new_names) %>%
  mutate(id = dgg_ids) %>%
  # split into shards to save memory
  split(1:200) %>%
  map_dfr(~gather(., key = 'name', value = 'value', -id) %>%
  separate(name, into = c('var', 'time_step'), sep = '[.]') %>%
  spread(var, value) %>%
  left_join(fixed_inputs, by = 'id') %>%
  mutate(crops = cropland / area,
            grazing = grazing / area,
            rice = ir_rice / area,
            pop = popc / area,
            irrigation = tot_irri / area,
            urban = uopp / area,
            used = urban + crops + grazing,
            .keep = 'unused') %>%
    anthromes_classify()) #%>%
## necessary to save ram, but not if run on cluster
write_csv(anthromes_dgg_upper, 'anthromes_dgg_upper2.csv')
gc()
read_csv('anthromes_dgg_upper2.csv') %>%
  mutate(time_step = factor(time_step, levels = time_key$time_step)) %>%
  arrange(id, time_step) %>%
  spread(time_step, anthrome) %>%
  write_csv('anthromes_dgg_upper.csv')
```



```{r}
hyde_dgg_lower <- readRDS('hyde_dgg_lower')

hyde_names_grepl <- str_c('cropland', 'grazing', 'ir_rice', 'popc', 'tot_irri', 'uopp', sep = '|')

var_names <- names(hyde_dgg_lower) %>%
  str_extract(hyde_names_grepl)

time_steps <- names(hyde_dgg_lower) %>%
  str_sub(start = str_length(var_names) + 5) %>%
  str_remove('_')

new_names <- paste(var_names, time_steps, sep = '.')

anthromes_dgg_lower <- hyde_dgg_lower %>%
    setNames(new_names) %>%
  mutate(id = dgg_ids) %>%
  split(1:200) %>%
  map_dfr(~gather(., key = 'name', value = 'value', -id) %>%
  separate(name, into = c('var', 'time_step'), sep = '[.]') %>%
  spread(var, value) %>%
  left_join(fixed_inputs, by = 'id') %>%
  mutate(crops = cropland / area,
            grazing = grazing / area,
            rice = ir_rice / area,
            pop = popc / area,
            irrigation = tot_irri / area,
            urban = uopp / area,
            used = urban + crops + grazing,
            .keep = 'unused') %>%
  anthromes_classify()) #%>%
## necassary to save ram, but not if run on cluster
write_csv(anthromes_dgg_lower, 'anthromes_dgg_lower2.csv')
gc()
read_csv('anthromes_dgg_lower2.csv') %>%
  mutate(time_step = factor(time_step, levels = time_key$time_step)) %>%
  arrange(id, time_step) %>%
  spread(time_step, anthrome) %>%
  write_csv('anthromes_dgg_lower.csv')
```




```{r}
write_csv(anthromes_dgg, 'anthromes_dgg.csv')
```

```{r}
anthromes_dgg <- read_csv('anthromes_dgg.csv', col_types = cols(.default = 'i'))
```

```{r}
anthromes_dgg_shp <- anthromes_dgg %>%
  mutate(geometry = dgg_land$geometry) %>%
  st_as_sf() %>%
  st_set_crs(4326)
  
write_sf(anthromes_dgg_shp, 'anthromes_dgg.shp')
```

# Create final masks and grids
```{r, eval = FALSE}
dgg_land <- read_sf('l12_ISEA3H_dgg_land.shp')

#this is erles mask
land_mask <- read_sf('../an12_dgg_cells.shp') %>%
  filter(DGG_status == 3) %>%
  pull(ANL12_ID)

fixed_inputs <- read_csv('fixed_inputs.csv') %>%
  mutate(id = dgg_land$id)

an12_fixed_inputs <- dgg_land %>% 
  filter(id %in% land_mask) %>% 
  left_join(fixed_inputs) %>%
  select(id, land_area, pot_veg, pot_vill, geometry) %>%
    st_set_crs(4326) # might not be necessary with s2?

write_sf(an12_fixed_inputs, 'an12_dgg_inputs.shp')
```

```{r}
an12_dgg_inputs <- read_sf('an12_dgg_inputs.shp')
an12_dgg <- read_csv('anthromes_dgg.csv', col_types = cols(.default = 'i')) %>%
  filter(id %in% an12_dgg_inputs$id)

write_csv(an12_dgg, 'an12_dgg.csv')

read_csv('anthromes_dgg_lower.csv', col_types = cols(.default = 'i')) %>%
  filter(id %in% an12_dgg_inputs$id) %>%
  write_csv('an12_dgg_lower.csv')

read_csv('anthromes_dgg_upper.csv', col_types = cols(.default = 'i')) %>%
  filter(id %in% an12_dgg_inputs$id) %>%
  write_csv('an12_dgg_upper.csv')

an12_dgg_inputs %>% dplyr::select(id) %>%
  left_join(an12_dgg) %>%
  write_sf('an12_dgg.shp')
```

